# Routilux v0.12.0 易用性与内建 Routines 改进计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 提升 routilux 易用性（装饰器 API + 链式构建）并重构内建 routines 以更好展示框架设计价值

**Architecture:** 添加 @routine 装饰器简化 routine 定义，添加 Flow.pipe() 链式方法简化流水线构建，删除 4 个低价值 routines，新增 6 个核心流水线模式 routines

**Tech Stack:** Python 3.11+, serilux, pytest, ruff

**Design Philosophy:** 轻量级、易扩展、稳定可靠的流水线库（不是框架）

---

## Phase 1: 删除低价值 Routines

### Task 1.1: 删除 TextClipper

**Files:**
- Delete: `routilux/builtin_routines/text_processing/text_clipper.py`
- Modify: `routilux/builtin_routines/text_processing/__init__.py`
- Modify: `routilux/builtin_routines/__init__.py`
- Modify: `routilux/__init__.py`

**Step 1: 删除文件**

```bash
rm routilux/builtin_routines/text_processing/text_clipper.py
```

**Step 2: 更新 text_processing/__init__.py**

移除 TextClipper 导出：

```python
from routilux.builtin_routines.text_processing.result_extractor import ResultExtractor

__all__ = [
    "ResultExtractor",
]
```

**Step 3: 更新 builtin_routines/__init__.py**

移除 TextClipper 导出：

```python
from routilux.builtin_routines.control_flow import ConditionalRouter
from routilux.builtin_routines.data_processing import DataTransformer, DataValidator
from routilux.builtin_routines.text_processing import ResultExtractor
from routilux.builtin_routines.utils import DataFlattener, TimeProvider

__all__ = [
    # Text processing
    "ResultExtractor",
    # Utils
    "TimeProvider",
    "DataFlattener",
    # Data processing
    "DataTransformer",
    "DataValidator",
    # Control flow
    "ConditionalRouter",
]
```

**Step 4: 更新 routilux/__init__.py**

移除 TextClipper 相关导出。

**Step 5: 运行测试验证**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 6: 提交**

```bash
git add -A
git commit -m "refactor: remove TextClipper (low-value builtin routine)"
```

---

### Task 1.2: 删除 TextRenderer

**Files:**
- Delete: `routilux/builtin_routines/text_processing/text_renderer.py`
- Modify: `routilux/builtin_routines/text_processing/__init__.py`

**Step 1: 删除文件**

```bash
rm routilux/builtin_routines/text_processing/text_renderer.py
```

**Step 2: 更新 __init__.py（已在 Task 1.1 完成）**

**Step 3: 运行测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 4: 提交**

```bash
git add -A
git commit -m "refactor: remove TextRenderer (low-value builtin routine)"
```

---

### Task 1.3: 删除 TimeProvider

**Files:**
- Delete: `routilux/builtin_routines/utils/time_provider.py`
- Modify: `routilux/builtin_routines/utils/__init__.py`
- Modify: `routilux/builtin_routines/__init__.py`
- Modify: `routilux/__init__.py`

**Step 1: 删除文件**

```bash
rm routilux/builtin_routines/utils/time_provider.py
```

**Step 2: 更新 utils/__init__.py**

```python
from routilux.builtin_routines.utils.data_flattener import DataFlattener

__all__ = [
    "DataFlattener",
]
```

**Step 3: 更新其他导出文件**

**Step 4: 运行测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 5: 提交**

```bash
git add -A
git commit -m "refactor: remove TimeProvider (low-value builtin routine)"
```

---

### Task 1.4: 删除 DataFlattener

**Files:**
- Delete: `routilux/builtin_routines/utils/data_flattener.py`
- Delete: `routilux/builtin_routines/utils/__init__.py` (如果为空)
- Modify: `routilux/builtin_routines/__init__.py`
- Modify: `routilux/__init__.py`

**Step 1: 删除文件**

```bash
rm routilux/builtin_routines/utils/data_flattener.py
rm routilux/builtin_routines/utils/__init__.py
rmdir routilux/builtin_routines/utils 2>/dev/null || true
```

**Step 2: 更新导出**

**Step 3: 运行测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 4: 提交**

```bash
git add -A
git commit -m "refactor: remove DataFlattener (low-value builtin routine)"
```

---

## Phase 2: 易用性提升 - @routine 装饰器

### Task 2.1: 编写 @routine 装饰器测试

**Files:**
- Create: `tests/test_decorators.py`

**Step 1: 创建测试文件**

```python
# tests/test_decorators.py
"""Tests for routilux decorators."""

import pytest
from routilux.decorators import routine
from routilux.core import Flow, Runtime


class TestRoutineDecorator:
    """Tests for @routine decorator."""

    def test_basic_routine_creation(self):
        """Test that @routine creates a valid Routine."""
        @routine()
        def double(data):
            return {"result": data * 2}

        # Should return a class, not instance
        assert callable(double)
        routine_instance = double()
        assert hasattr(routine_instance, '_id')
        assert hasattr(routine_instance, 'input_slot')
        assert hasattr(routine_instance, 'output_event')

    def test_routine_with_custom_slot_name(self):
        """Test @routine with custom slot name."""
        @routine(input_slot="request", output_event="response")
        def process(data):
            return {"processed": data}

        routine_instance = process()
        assert routine_instance.get_slot("request") is not None
        assert routine_instance.get_event("response") is not None

    def test_routine_in_flow(self):
        """Test using @routine decorated function in a Flow."""
        @routine()
        def add_one(data):
            return {"result": data + 1}

        flow = Flow("test_flow")
        routine_instance = add_one()
        flow.add_routine(routine_instance, "adder")

        assert flow.get_routine("adder") is not None

    def test_routine_preserves_function_name(self):
        """Test that decorated routine preserves original function name."""
        @routine()
        def my_custom_processor(data):
            return data

        assert my_custom_processor.__name__ == "my_custom_processor"
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/test_decorators.py -v
```

Expected: FAIL - `ImportError: cannot import name 'routine' from 'routilux.decorators'`

**Step 3: 提交**

```bash
git add tests/test_decorators.py
git commit -m "test: add failing tests for @routine decorator"
```

---

### Task 2.2: 实现 @routine 装饰器

**Files:**
- Create: `routilux/decorators.py`
- Modify: `routilux/__init__.py`

**Step 1: 创建 decorators.py**

```python
# routilux/decorators.py
"""Decorators for simplifying routine creation."""

from __future__ import annotations

from typing import Any, Callable

from routilux.core import Routine


def routine(
    input_slot: str = "input",
    output_event: str = "output",
) -> Callable[[Callable], type[Routine]]:
    """Decorator that converts a function into a Routine class.

    This simplifies routine creation by automatically:
    - Creating input slot and output event
    - Setting up standard activation policy
    - Wiring the function as the logic handler

    Args:
        input_slot: Name of the input slot (default: "input")
        output_event: Name of the output event (default: "output")

    Returns:
        A decorator that converts the function to a Routine class

    Examples:
        >>> @routine()
        ... def process(data):
        ...     return {"result": data * 2}
        ...
        >>> routine_instance = process()
        >>> # Use in a Flow

        >>> @routine(input_slot="request", output_event="response")
        ... def api_handler(data):
        ...     return {"status": "ok", "data": data}
    """

    def decorator(func: Callable[[Any], Any]) -> type[Routine]:
        class FunctionRoutine(Routine):
            """Routine wrapper for a simple function."""

            def __init__(self):
                super().__init__()
                # Create input slot
                setattr(self, f"{input_slot}_slot", self.add_slot(input_slot))
                # Create output event
                setattr(self, f"{output_event}_event", self.add_event(output_event))
                # Store the function
                self._func = func
                # Set up standard activation policy
                self.set_activation_policy(
                    lambda slots, worker_state: (
                        len(slots[input_slot]) > 0,
                        {input_slot: slots[input_slot].consume_all_new()},
                        "slot_activated",
                    )
                )
                # Set up logic
                self.set_logic(self._run_logic)

            def _run_logic(self, **kwargs: Any) -> None:
                """Execute the wrapped function for each data point."""
                data_list = kwargs.get(input_slot, [])
                if not isinstance(data_list, list):
                    data_list = [data_list]

                for data in data_list:
                    try:
                        result = self._func(data)
                        self.emit(output_event, result=result)
                    except Exception as e:
                        self.emit(output_event, result=None, error=str(e))

        # Preserve function metadata
        FunctionRoutine.__name__ = func.__name__
        FunctionRoutine.__qualname__ = func.__qualname__
        FunctionRoutine.__doc__ = func.__doc__
        FunctionRoutine.__module__ = func.__module__

        return FunctionRoutine

    return decorator
```

**Step 2: 更新 routilux/__init__.py**

添加导出：

```python
# 在导入区域添加
from routilux.decorators import routine

# 在 __all__ 中添加
__all__ = [
    # ... existing exports ...
    # Decorators
    "routine",
    # ...
]
```

**Step 3: 运行测试验证通过**

```bash
pytest tests/test_decorators.py -v
```

Expected: PASS

**Step 4: 运行所有测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 5: 提交**

```bash
git add routilux/decorators.py routilux/__init__.py
git commit -m "feat: add @routine decorator for simplified routine creation"
```

---

## Phase 3: 易用性提升 - Flow.pipe() 链式方法

### Task 3.1: 编写 Flow.pipe() 测试

**Files:**
- Create: `tests/test_flow_pipe.py`

**Step 1: 创建测试文件**

```python
# tests/test_flow_pipe.py
"""Tests for Flow.pipe() chain method."""

import pytest
from routilux.core import Flow, Routine


class SimpleRoutine(Routine):
    """Simple test routine."""

    def __init__(self, name="simple"):
        super().__init__()
        self._test_name = name
        self.input_slot = self.add_slot("input")
        self.output_event = self.add_event("output")
        self.set_activation_policy(
            lambda slots, ws: (
                len(slots["input"]) > 0,
                {"input": slots["input"].consume_all_new()},
                "activated",
            )
        )
        self.set_logic(lambda **kw: self.emit("output", data=kw.get("input")))


class TestFlowPipe:
    """Tests for Flow.pipe() method."""

    def test_pipe_single_routine(self):
        """Test adding a single routine with pipe()."""
        flow = Flow("test_flow")
        r1 = SimpleRoutine("r1")

        result = flow.pipe(r1, "step1")

        # Should return self for chaining
        assert result is flow
        assert flow.get_routine("step1") is not None

    def test_pipe_chain_multiple_routines(self):
        """Test chaining multiple routines with pipe()."""
        flow = Flow("test_flow")
        r1 = SimpleRoutine("r1")
        r2 = SimpleRoutine("r2")
        r3 = SimpleRoutine("r3")

        flow.pipe(r1, "step1").pipe(r2, "step2").pipe(r3, "step3")

        # All routines should be added
        assert flow.get_routine("step1") is not None
        assert flow.get_routine("step2") is not None
        assert flow.get_routine("step3") is not None

        # Connections should be automatic
        connections = flow.get_connections_for_event(r1.output_event)
        assert len(connections) == 1
        assert connections[0].target_slot.name == "input"

    def test_pipe_auto_naming(self):
        """Test pipe with auto-generated routine ID."""
        flow = Flow("test_flow")
        r1 = SimpleRoutine("r1")

        flow.pipe(r1)  # No explicit ID

        # Should use routine's _id as default
        assert flow.get_routine(r1._id) is not None
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/test_flow_pipe.py -v
```

Expected: FAIL - `AttributeError: 'Flow' object has no attribute 'pipe'`

**Step 3: 提交**

```bash
git add tests/test_flow_pipe.py
git commit -m "test: add failing tests for Flow.pipe() method"
```

---

### Task 3.2: 实现 Flow.pipe() 方法

**Files:**
- Modify: `routilux/core/flow.py`

**Step 1: 在 Flow 类中添加 pipe() 方法**

找到 Flow 类，添加以下方法和属性：

```python
# 在 __init__ 中添加
self._last_pipe_routine_id: str | None = None

def pipe(
    self,
    routine: Routine,
    routine_id: str | None = None,
    from_routine: str | None = None,
    from_event: str = "output",
    to_slot: str = "input",
) -> Flow:
    """Add a routine and automatically connect to the previous one.

    This enables fluent/chained flow construction.

    Args:
        routine: The routine to add
        routine_id: ID for the routine (defaults to routine._id)
        from_routine: Source routine ID (defaults to last piped routine)
        from_event: Source event name (default: "output")
        to_slot: Target slot name (default: "input")

    Returns:
        self for method chaining

    Examples:
        >>> flow = (Flow("pipeline")
        ...     .pipe(Step1(), "step1")
        ...     .pipe(Step2(), "step2")
        ...     .pipe(Step3(), "step3"))
    """
    # Use provided ID or routine's default
    rid = routine_id or routine._id

    # Add the routine
    self.add_routine(routine, rid)

    # Connect to previous routine if exists
    source_id = from_routine or self._last_pipe_routine_id
    if source_id is not None:
        self.connect(source_id, from_event, rid, to_slot)

    # Remember this routine for next pipe()
    self._last_pipe_routine_id = rid

    return self
```

**Step 2: 运行测试验证通过**

```bash
pytest tests/test_flow_pipe.py -v
```

Expected: PASS

**Step 3: 运行所有测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v --tb=short
```

**Step 4: 提交**

```bash
git add routilux/core/flow.py
git commit -m "feat: add Flow.pipe() method for chained flow construction"
```

---

## Phase 4: 新增核心 Routines - Aggregator

### Task 4.1: 编写 Aggregator 测试

**Files:**
- Create: `tests/builtin_routines/test_aggregator.py`

**Step 1: 创建测试文件**

```python
# tests/builtin_routines/test_aggregator.py
"""Tests for Aggregator routine."""

import pytest
from routilux.builtin_routines.control_flow.aggregator import Aggregator


class TestAggregator:
    """Tests for Aggregator routine."""

    def test_aggregator_creation(self):
        """Test creating an Aggregator routine."""
        agg = Aggregator()
        agg.set_config(
            slots=["user_data", "order_data"],
            mode="all",
        )

        assert agg.get_config("mode") == "all"
        assert agg.get_config("slots") == ["user_data", "order_data"]

    def test_aggregator_has_multiple_slots(self):
        """Test that Aggregator creates multiple input slots."""
        agg = Aggregator()
        agg.set_config(slots=["a", "b", "c"])

        # Should have slots for each input
        assert agg.get_slot("a") is not None
        assert agg.get_slot("b") is not None
        assert agg.get_slot("c") is not None

    def test_aggregator_waits_for_all(self):
        """Test that Aggregator waits for all slots to have data."""
        agg = Aggregator()
        agg.set_config(
            slots=["a", "b"],
            mode="all",
        )

        # Simulate receiving data on slot 'a' only
        agg.get_slot("a").enqueue({"data": 1}, "source", None)

        # Should not be ready yet
        # (This tests the activation policy concept)

    def test_aggregator_merges_data(self):
        """Test that Aggregator merges data from all slots."""
        agg = Aggregator()
        agg.set_config(
            slots=["a", "b"],
            mode="all",
            merge_strategy="dict",
        )

        # This would be tested more thoroughly with a full flow execution
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/builtin_routines/test_aggregator.py -v
```

Expected: FAIL - `ModuleNotFoundError`

**Step 3: 提交**

```bash
git add tests/builtin_routines/test_aggregator.py
git commit -m "test: add failing tests for Aggregator routine"
```

---

### Task 4.2: 实现 Aggregator Routine

**Files:**
- Create: `routilux/builtin_routines/control_flow/aggregator.py`
- Modify: `routilux/builtin_routines/control_flow/__init__.py`

**Step 1: 创建 aggregator.py**

```python
# routilux/builtin_routines/control_flow/aggregator.py
"""Aggregator routine for combining multiple inputs."""

from __future__ import annotations

from typing import Any

from routilux.core import Routine


class Aggregator(Routine):
    """Routine that waits for multiple inputs and combines them.

    The Aggregator collects data from multiple input slots and emits
    a combined output when the specified condition is met.

    Features:
        - Wait for all slots to have data (mode="all")
        - Wait for any slot to have data (mode="any")
        - Wait for N of M slots (mode="n_of_m")
        - Configurable timeout
        - Multiple merge strategies

    Configuration:
        slots: List of slot names to aggregate
        mode: "all" | "any" | "n_of_m"
        n: For n_of_m mode, how many slots need data
        timeout: Maximum wait time in seconds
        merge_strategy: "dict" | "list" | callable

    Examples:
        >>> agg = Aggregator()
        >>> agg.set_config(
        ...     slots=["user_data", "order_data", "payment_data"],
        ...     mode="all",
        ...     timeout=30.0,
        ... )
    """

    def __init__(self):
        super().__init__()
        self.set_config(
            slots=[],
            mode="all",
            n=None,
            timeout=30.0,
            merge_strategy="dict",
        )

        # Output event
        self.output_event = self.add_event("output", ["aggregated_data", "sources"])

        # Will create slots dynamically based on config
        self._slots_created = False

    def _ensure_slots(self) -> None:
        """Create slots based on configuration."""
        if self._slots_created:
            return

        slot_names = self.get_config("slots", [])
        for name in slot_names:
            if self.get_slot(name) is None:
                self.add_slot(name)

        self._slots_created = True

    def _check_readiness(self, slots: dict[str, Any]) -> tuple[bool, list[str]]:
        """Check if aggregation condition is met.

        Returns:
            Tuple of (is_ready, list_of_ready_slot_names)
        """
        mode = self.get_config("mode", "all")
        slot_names = self.get_config("slots", [])

        ready_slots = []
        for name in slot_names:
            if name in slots and len(slots[name]) > 0:
                ready_slots.append(name)

        if mode == "all":
            return len(ready_slots) == len(slot_names), ready_slots
        elif mode == "any":
            return len(ready_slots) > 0, ready_slots
        elif mode == "n_of_m":
            n = self.get_config("n", 1)
            return len(ready_slots) >= n, ready_slots

        return False, []

    def _merge_data(self, data: dict[str, Any], sources: list[str]) -> Any:
        """Merge data from multiple sources."""
        strategy = self.get_config("merge_strategy", "dict")

        if callable(strategy):
            return strategy(data, sources)
        elif strategy == "list":
            return list(data.values())
        else:  # dict
            return data

    def _handle_activation(self, **kwargs: Any) -> None:
        """Handle activation when slots have data."""
        self._ensure_slots()

        slot_names = self.get_config("slots", [])
        slot_data = {}

        # Collect data from ready slots
        for name in slot_names:
            slot = self.get_slot(name)
            if slot and slot.get_unconsumed_count() > 0:
                slot_data[name] = slot.consume_all_new()

        # Check if ready to emit
        is_ready, sources = self._check_readiness(
            {k: v for k, v in kwargs.items() if k in slot_names}
        )

        if is_ready:
            merged = self._merge_data(slot_data, sources)
            self.emit("output", aggregated_data=merged, sources=sources)
```

**Step 2: 更新 control_flow/__init__.py**

```python
from routilux.builtin_routines.control_flow.conditional_router import ConditionalRouter
from routilux.builtin_routines.control_flow.aggregator import Aggregator

__all__ = [
    "ConditionalRouter",
    "Aggregator",
]
```

**Step 3: 运行测试**

```bash
pytest tests/builtin_routines/test_aggregator.py -v
```

**Step 4: 提交**

```bash
git add routilux/builtin_routines/control_flow/aggregator.py
git add routilux/builtin_routines/control_flow/__init__.py
git commit -m "feat: add Aggregator routine for multi-input aggregation"
```

---

## Phase 5: 新增核心 Routines - Batcher

### Task 5.1: 编写 Batcher 测试

**Files:**
- Create: `tests/builtin_routines/test_batcher.py`

**Step 1: 创建测试**

```python
# tests/builtin_routines/test_batcher.py
"""Tests for Batcher routine."""

import pytest
from routilux.builtin_routines.control_flow.batcher import Batcher


class TestBatcher:
    """Tests for Batcher routine."""

    def test_batcher_creation(self):
        """Test creating a Batcher routine."""
        batcher = Batcher()
        batcher.set_config(batch_size=100, batch_timeout=5.0)

        assert batcher.get_config("batch_size") == 100
        assert batcher.get_config("batch_timeout") == 5.0

    def test_batcher_accumulates_data(self):
        """Test that Batcher accumulates data until batch_size."""
        batcher = Batcher()
        batcher.set_config(batch_size=3)

        # Add data one by one
        batcher.input_slot.enqueue({"id": 1}, "source", None)
        batcher.input_slot.enqueue({"id": 2}, "source", None)

        # Not enough data yet - batch should not emit
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/builtin_routines/test_batcher.py -v
```

**Step 3: 提交**

```bash
git add tests/builtin_routines/test_batcher.py
git commit -m "test: add failing tests for Batcher routine"
```

---

### Task 5.2: 实现 Batcher Routine

**Files:**
- Create: `routilux/builtin_routines/control_flow/batcher.py`

**Step 1: 创建 batcher.py**

```python
# routilux/builtin_routines/control_flow/batcher.py
"""Batcher routine for collecting data into batches."""

from __future__ import annotations

import time
from typing import Any

from routilux.core import Routine


class Batcher(Routine):
    """Routine that collects data into batches before emitting.

    The Batcher accumulates input data and emits a batch when either:
    - batch_size items are collected
    - batch_timeout seconds have elapsed since first item

    Configuration:
        batch_size: Number of items to collect (default: 100)
        batch_timeout: Max wait time in seconds (default: 5.0)
        flush_on_shutdown: Emit remaining items on shutdown (default: True)

    Examples:
        >>> batcher = Batcher()
        >>> batcher.set_config(batch_size=50, batch_timeout=10.0)
    """

    def __init__(self):
        super().__init__()
        self.set_config(
            batch_size=100,
            batch_timeout=5.0,
            flush_on_shutdown=True,
        )

        self.input_slot = self.add_slot("input")
        self.output_event = self.add_event("output", ["batch", "count"])

        self._batch: list[Any] = []
        self._first_item_time: float | None = None

        self.set_activation_policy(
            lambda slots, ws: (
                len(slots["input"]) > 0,
                {"input": slots["input"].consume_all_new()},
                "slot_activated",
            )
        )
        self.set_logic(self._handle_input)

    def _handle_input(self, **kwargs: Any) -> None:
        """Handle incoming data and emit batch if ready."""
        data_list = kwargs.get("input", [])
        batch_size = self.get_config("batch_size", 100)
        batch_timeout = self.get_config("batch_timeout", 5.0)

        current_time = time.time()

        for data in data_list:
            # Track when first item arrived
            if self._first_item_time is None:
                self._first_item_time = current_time

            self._batch.append(data)

            # Check if batch is ready by size
            if len(self._batch) >= batch_size:
                self._emit_batch()
                return

        # Check if batch is ready by timeout
        if self._first_item_time is not None:
            elapsed = current_time - self._first_item_time
            if elapsed >= batch_timeout:
                self._emit_batch()

    def _emit_batch(self) -> None:
        """Emit the current batch and reset."""
        if self._batch:
            self.emit("output", batch=self._batch.copy(), count=len(self._batch))
            self._batch = []
            self._first_item_time = None
```

**Step 2: 更新 __init__.py 添加导出**

**Step 3: 运行测试**

```bash
pytest tests/builtin_routines/test_batcher.py -v
```

**Step 4: 提交**

```bash
git add routilux/builtin_routines/control_flow/batcher.py
git commit -m "feat: add Batcher routine for batch collection"
```

---

## Phase 6: 新增核心 Routines - Filter

### Task 6.1: 编写 Filter 测试

**Files:**
- Create: `tests/builtin_routines/test_filter.py`

```python
# tests/builtin_routines/test_filter.py
"""Tests for Filter routine."""

import pytest
from routilux.builtin_routines.data_processing.filter import Filter


class TestFilter:
    """Tests for Filter routine."""

    def test_filter_creation(self):
        """Test creating a Filter routine."""
        f = Filter()
        f.set_config(condition=lambda d: d.get("active", False))

        assert f.get_config("condition") is not None

    def test_filter_passes_matching_data(self):
        """Test that Filter passes data matching condition."""
        f = Filter()
        f.set_config(
            condition=lambda d: d.get("value", 0) > 10,
            pass_event="passed",
            reject_event="rejected",
        )

        # This test would need full flow execution to verify properly
```

**Step 2: 提交**

```bash
git add tests/builtin_routines/test_filter.py
git commit -m "test: add failing tests for Filter routine"
```

---

### Task 6.2: 实现 Filter Routine

**Files:**
- Create: `routilux/builtin_routines/data_processing/filter.py`

```python
# routilux/builtin_routines/data_processing/filter.py
"""Filter routine for conditional data routing."""

from __future__ import annotations

from typing import Any, Callable

from routilux.core import Routine


class Filter(Routine):
    """Routine that filters data based on a condition.

    Data that matches the condition is emitted to pass_event,
    data that doesn't match is emitted to reject_event.

    Configuration:
        condition: Callable that returns True to pass, False to reject
        pass_event: Event name for passing data (default: "passed")
        reject_event: Event name for rejected data (default: "rejected")

    Examples:
        >>> f = Filter()
        >>> f.set_config(
        ...     condition=lambda d: d.get("status") == "active",
        ...     pass_event="active",
        ...     reject_event="inactive",
        ... )
    """

    def __init__(self):
        super().__init__()
        self.set_config(
            condition=None,
            pass_event="passed",
            reject_event="rejected",
        )

        self.input_slot = self.add_slot("input")
        self.passed_event = self.add_event("passed", ["data"])
        self.rejected_event = self.add_event("rejected", ["data"])

        self.set_activation_policy(
            lambda slots, ws: (
                len(slots["input"]) > 0,
                {"input": slots["input"].consume_all_new()},
                "slot_activated",
            )
        )
        self.set_logic(self._handle_input)

    def _handle_input(self, **kwargs: Any) -> None:
        """Handle input and route based on condition."""
        data_list = kwargs.get("input", [])
        condition = self.get_config("condition")
        pass_event = self.get_config("pass_event", "passed")
        reject_event = self.get_config("reject_event", "rejected")

        for data in data_list:
            try:
                if condition is None:
                    # No condition = pass everything
                    passes = True
                elif callable(condition):
                    passes = bool(condition(data))
                else:
                    passes = bool(condition)

                if passes:
                    self.emit(pass_event, data=data)
                else:
                    self.emit(reject_event, data=data)

            except Exception:
                # On error, reject
                self.emit(reject_event, data=data)
```

**Step 2: 运行测试并提交**

```bash
pytest tests/builtin_routines/test_filter.py -v
git add -A && git commit -m "feat: add Filter routine for conditional data routing"
```

---

## Phase 7: 新增核心 Routines - Splitter

### Task 7.1: 编写 Splitter 测试

```python
# tests/builtin_routines/test_splitter.py
"""Tests for Splitter routine."""

import pytest
from routilux.builtin_routines.control_flow.splitter import Splitter


class TestSplitter:
    """Tests for Splitter routine."""

    def test_splitter_creation(self):
        """Test creating a Splitter routine."""
        s = Splitter()
        s.set_config(field="items")

        assert s.get_config("field") == "items"

    def test_splitter_splits_list(self):
        """Test that Splitter splits a list into individual items."""
        s = Splitter()
        s.set_config(field="items")

        # Would verify that [1, 2, 3] becomes three separate emits
```

**提交:**

```bash
git add tests/builtin_routines/test_splitter.py
git commit -m "test: add failing tests for Splitter routine"
```

---

### Task 7.2: 实现 Splitter Routine

```python
# routilux/builtin_routines/control_flow/splitter.py
"""Splitter routine for dividing lists into individual items."""

from __future__ import annotations

from typing import Any

from routilux.core import Routine


class Splitter(Routine):
    """Routine that splits a list into individual items.

    Takes a list from a specified field and emits each item separately.

    Configuration:
        field: Field name containing the list to split (default: "items")
        emit_single: Emit even for single items (default: True)

    Examples:
        >>> s = Splitter()
        >>> s.set_config(field="results")
        >>> # Input: {"results": [1, 2, 3]}
        >>> # Output: three emits with data 1, 2, 3
    """

    def __init__(self):
        super().__init__()
        self.set_config(
            field="items",
            emit_single=True,
        )

        self.input_slot = self.add_slot("input")
        self.output_event = self.add_event("output", ["item", "index", "total"])

        self.set_activation_policy(
            lambda slots, ws: (
                len(slots["input"]) > 0,
                {"input": slots["input"].consume_all_new()},
                "slot_activated",
            )
        )
        self.set_logic(self._handle_input)

    def _handle_input(self, **kwargs: Any) -> None:
        """Handle input and split lists into individual items."""
        data_list = kwargs.get("input", [])
        field = self.get_config("field", "items")
        emit_single = self.get_config("emit_single", True)

        for data in data_list:
            if not isinstance(data, dict):
                continue

            items = data.get(field, [])
            if not isinstance(items, list):
                items = [items]

            if not items:
                continue

            total = len(items)
            if total == 1 and not emit_single:
                # Single item and emit_single is False
                self.emit("output", item=items[0], index=0, total=1)
            else:
                for i, item in enumerate(items):
                    self.emit("output", item=item, index=i, total=total)
```

**提交:**

```bash
git add routilux/builtin_routines/control_flow/splitter.py
git commit -m "feat: add Splitter routine for list splitting"
```

---

## Phase 8: 更新导出和文档

### Task 8.1: 更新 routilux/__init__.py

**Step 1: 更新导出**

确保所有新的 routines 和装饰器都被正确导出：

```python
# 装饰器
from routilux.decorators import routine

# 内建 routines
from routilux.builtin_routines import (
    # Control Flow
    ConditionalRouter,
    Aggregator,
    Batcher,
    Splitter,
    # Data Processing
    ResultExtractor,
    Filter,
    DataTransformer,
    DataValidator,
)

__all__ = [
    # Decorators
    "routine",
    # Control Flow
    "ConditionalRouter",
    "Aggregator",
    "Batcher",
    "Splitter",
    # Data Processing
    "ResultExtractor",
    "Filter",
    "DataTransformer",
    "DataValidator",
    # Core
    "Flow",
    "Routine",
    "Runtime",
    # ... 其他导出
]
```

**Step 2: 运行所有测试**

```bash
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v
```

**Step 3: 提交**

```bash
git add routilux/__init__.py
git commit -m "chore: update exports for v0.12.0"
```

---

### Task 8.2: 更新 CHANGELOG.md

**Step 1: 添加 v0.12.0 变更记录**

```markdown
## [0.12.0] - 2026-02-XX

### Added

#### 易用性改进
- **@routine 装饰器**: 简化 routine 定义，只需 3 行代码
- **Flow.pipe() 方法**: 链式构建流水线

#### 新增内建 Routines
- **Aggregator**: 多输入聚合 routine
- **Batcher**: 批量收集 routine
- **Filter**: 条件过滤 routine
- **Splitter**: 数据拆分 routine

### Removed
- TextClipper (功能过于单一)
- TextRenderer (用例狭窄)
- TimeProvider (不体现设计价值)
- DataFlattener (功能简单)
```

**Step 2: 提交**

```bash
git add CHANGELOG.md
git commit -m "docs: update CHANGELOG for v0.12.0"
```

---

## Phase 9: 最终验证

### Task 9.1: 运行完整测试套件

```bash
# 运行所有测试
pytest tests/ --ignore=tests/cli --ignore=tests/server --ignore=tests/benchmarks -v

# 检查覆盖率
pytest tests/ --cov=routilux --cov-report=term

# 代码质量检查
ruff check routilux/
ruff format routilux/ --check
```

### Task 9.2: 版本发布

```bash
# 更新版本号
# routilux/__init__.py: __version__ = "0.12.0"

# 提交
git add -A
git commit -m "release: v0.12.0"

# 打 tag
git tag v0.12.0

# 推送
git push origin main --tags
```

---

## 文件修改汇总

### 新建文件

| 文件 | 说明 |
|------|------|
| `routilux/decorators.py` | @routine 装饰器 |
| `routilux/builtin_routines/control_flow/aggregator.py` | Aggregator routine |
| `routilux/builtin_routines/control_flow/batcher.py` | Batcher routine |
| `routilux/builtin_routines/control_flow/splitter.py` | Splitter routine |
| `routilux/builtin_routines/data_processing/filter.py` | Filter routine |
| `tests/test_decorators.py` | 装饰器测试 |
| `tests/test_flow_pipe.py` | Flow.pipe() 测试 |
| `tests/builtin_routines/test_aggregator.py` | Aggregator 测试 |
| `tests/builtin_routines/test_batcher.py` | Batcher 测试 |
| `tests/builtin_routines/test_filter.py` | Filter 测试 |
| `tests/builtin_routines/test_splitter.py` | Splitter 测试 |

### 删除文件

| 文件 | 原因 |
|------|------|
| `routilux/builtin_routines/text_processing/text_clipper.py` | 功能单一 |
| `routilux/builtin_routines/text_processing/text_renderer.py` | 用例狭窄 |
| `routilux/builtin_routines/utils/time_provider.py` | 不体现价值 |
| `routilux/builtin_routines/utils/data_flattener.py` | 功能简单 |

### 修改文件

| 文件 | 修改内容 |
|------|----------|
| `routilux/__init__.py` | 更新导出 |
| `routilux/core/flow.py` | 添加 pipe() 方法 |
| `routilux/builtin_routines/__init__.py` | 更新导出 |
| `routilux/builtin_routines/control_flow/__init__.py` | 添加新 routines |
| `routilux/builtin_routines/data_processing/__init__.py` | 添加 Filter |
| `CHANGELOG.md` | 更新变更日志 |
