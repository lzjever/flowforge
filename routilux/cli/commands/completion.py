"""Shell completion command implementation."""

import os

import click

SHELLS = ["bash", "zsh", "fish"]


@click.command("completion")
@click.argument("shell", type=click.Choice(SHELLS))
@click.option("--install", is_flag=True, help="Install completion script")
@click.pass_context
def completion(ctx, shell, install):
    """Generate shell completion script.

    Generate completion script for the specified shell.

    \b
    Examples:
        # Generate bash completion
        $ routilux completion bash > /etc/bash_completion.d/routilux

        # Generate zsh completion
        $ routilux completion zsh > ~/.zsh/completion/_routilux

        # Generate fish completion
        $ routilux completion fish > ~/.config/fish/completions/routilux.fish

        # Auto-install (bash)
        $ routilux completion bash --install
    """
    quiet = ctx.obj.get("quiet", False)

    if shell == "bash":
        script = _generate_bash_completion()
    elif shell == "zsh":
        script = _generate_zsh_completion()
    elif shell == "fish":
        script = _generate_fish_completion()
    else:
        raise click.BadParameter(f"Unsupported shell: {shell}")

    if install:
        _install_completion(shell, script, quiet)
    else:
        click.echo(script)


def _generate_bash_completion() -> str:
    """Generate Bash completion script."""
    return """# Bash completion for routilux
# Generated by: routilux completion bash

_routilux_completion() {
    local IFS=$'\\n'
    local response

    response=$(env COMP_WORDS="${COMP_WORDS[*]}" COMP_CWORD=$COMP_CWORD _ROUTILUX_COMPLETE=bash-complete $1 2>/dev/null)

    for completion in $response; do
        IFS=',' read type value <<< "$completion"

        if [[ $type == 'dir' ]]; then
            COMPREPLY=()
            compopt -o dirnames
        elif [[ $type == 'file' ]]; then
            COMPREPLY=()
            compopt -o default
        elif [[ $type == 'plain' ]]; then
            COMPREPLY+=($value)
        fi
    done

    return 0
}

# Basic completion fallback
_routilux_completion_fallback() {
    local cur prev words cword
    _init_completion || return

    local commands="init run list validate server completion"

    if (( cword == 1 )); then
        COMPREPLY=($(compgen -W "$commands" -- "$cur"))
        return 0
    fi

    case ${words[1]} in
        init)
            COMPREPLY=($(compgen -W "--name -n --force --help" -- "$cur"))
            ;;
        run)
            case $prev in
                -w|--workflow|-o|--output)
                    _filedir
                    ;;
                --routines-dir)
                    _filedir -d
                    ;;
                *)
                    COMPREPLY=($(compgen -W "-w --workflow -p --param -o --output --timeout --routines-dir --help" -- "$cur"))
                    ;;
            esac
            ;;
        list)
            case $prev in
                --dir)
                    _filedir -d
                    ;;
                *)
                    COMPREPLY=($(compgen -W "routines flows --category -c --routines-dir --dir --format --help" -- "$cur"))
                    ;;
            esac
            ;;
        validate)
            case $prev in
                -w|--workflow)
                    _filedir
                    ;;
                --routines-dir)
                    _filedir -d
                    ;;
                *)
                    COMPREPLY=($(compgen -W "-w --workflow --routines-dir --help" -- "$cur"))
                    ;;
            esac
            ;;
        server)
            if (( cword == 2 )); then
                COMPREPLY=($(compgen -W "start stop status --help" -- "$cur"))
            else
                case ${words[2]} in
                    start)
                        COMPREPLY=($(compgen -W "--host --port --routines-dir --reload --log-level --help" -- "$cur"))
                        ;;
                    stop)
                        COMPREPLY=($(compgen -W "--port --force -f --help" -- "$cur"))
                        ;;
                    status)
                        COMPREPLY=($(compgen -W "--port --json --help" -- "$cur"))
                        ;;
                esac
            fi
            ;;
        completion)
            COMPREPLY=($(compgen -W "bash zsh fish --install --help" -- "$cur"))
            ;;
    esac
}

complete -o nosort -F _routilux_completion_fallback routilux
"""


def _generate_zsh_completion() -> str:
    """Generate Zsh completion script."""
    return """#compdef routilux
# Generated by: routilux completion zsh

_routilux() {
    local -a commands
    commands=(
        'init:Initialize a new routilux project'
        'run:Run a workflow from a DSL file'
        'list:List available routines or flows'
        'validate:Validate a workflow DSL file'
        'server:Manage the routilux HTTP server'
        'completion:Generate shell completion script'
    )

    local -a global_opts
    global_opts=(
        '--routines-dir[Additional directories to scan for routines]:directory:_directories'
        '--config[Path to configuration file]:file:_files'
        {-v,--verbose}'[Enable verbose output]'
        {-q,--quiet}'[Minimal output]'
        '--version[Show version]'
        '--help[Show help]'
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        _arguments $global_opts
        return
    fi

    case ${words[2]} in
        init)
            _arguments \\
                '(--name -n)'{--name,-n}'[Project name]:name' \\
                '--force[Overwrite existing files]' \\
                '--help[Show help]'
            ;;
        run)
            _arguments \\
                {-w,--workflow}'[Path to workflow DSL file]:file:_files -g "*.yaml\\|*.yml\\|*.json"' \\
                {-p,--param}'[Parameters in KEY=VALUE format]:param' \\
                {-o,--output}'[Output file for results]:file:_files' \\
                '--timeout[Execution timeout in seconds]:seconds' \\
                '--routines-dir[Additional routines directory]:directory:_directories' \\
                '--help[Show help]'
            ;;
        list)
            _arguments \\
                ':resource:(routines flows)' \\
                {-c,--category}'[Filter by category]:category' \\
                '--routines-dir[Additional routines directory]:directory:_directories' \\
                '--dir[Directory to scan for flows]:directory:_directories' \\
                '--format[Output format]:format:(table json plain)' \\
                '--help[Show help]'
            ;;
        validate)
            _arguments \\
                {-w,--workflow}'[Path to workflow DSL file]:file:_files -g "*.yaml\\|*.yml\\|*.json"' \\
                '--routines-dir[Additional routines directory]:directory:_directories' \\
                '--help[Show help]'
            ;;
        server)
            local -a server_commands
            server_commands=(
                'start:Start the routilux HTTP server'
                'stop:Stop a running routilux server'
                'status:Check server status'
            )
            if (( CURRENT == 3 )); then
                _describe 'server command' server_commands
            else
                case ${words[3]} in
                    start)
                        _arguments \\
                            '--host[Host to bind to]:host' \\
                            '--port[Port to bind to]:port' \\
                            '--routines-dir[Additional routines directory]:directory:_directories' \\
                            '--reload[Enable auto-reload for development]' \\
                            '--log-level[Log level]:level:(debug info warning error critical)' \\
                            '--help[Show help]'
                        ;;
                    stop)
                        _arguments \\
                            '--port[Port of the server to stop]:port' \\
                            {-f,--force}'[Force kill the server]' \\
                            '--help[Show help]'
                        ;;
                    status)
                        _arguments \\
                            '--port[Port to check]:port' \\
                            '--json[Output as JSON]' \\
                            '--help[Show help]'
                        ;;
                esac
            fi
            ;;
        completion)
            _arguments \\
                ':shell:(bash zsh fish)' \\
                '--install[Install completion script]' \\
                '--help[Show help]'
            ;;
    esac
}

_routilux
"""


def _generate_fish_completion() -> str:
    """Generate Fish completion script."""
    return """# Fish completion for routilux
# Generated by: routilux completion fish

# Main command
complete -c routilux -f

# Global options
complete -c routilux -l routines-dir -d 'Additional routines directories' -r
complete -c routilux -l config -d 'Path to configuration file' -r
complete -c routilux -s v -l verbose -d 'Enable verbose output'
complete -c routilux -s q -l quiet -d 'Minimal output'
complete -c routilux -l version -d 'Show version'
complete -c routilux -l help -d 'Show help'

# Commands
complete -c routilux -n __fish_use_subcommand -a init -d 'Initialize a new project'
complete -c routilux -n __fish_use_subcommand -a run -d 'Run a workflow'
complete -c routilux -n __fish_use_subcommand -a list -d 'List resources'
complete -c routilux -n __fish_use_subcommand -a validate -d 'Validate DSL'
complete -c routilux -n __fish_use_subcommand -a server -d 'Manage server'
complete -c routilux -n __fish_use_subcommand -a completion -d 'Generate completion'

# init options
complete -c routilux -n '__fish_seen_subcommand_from init' -l name -s n -d 'Project name'
complete -c routilux -n '__fish_seen_subcommand_from init' -l force -d 'Overwrite files'
complete -c routilux -n '__fish_seen_subcommand_from init' -l help -d 'Show help'

# run options
complete -c routilux -n '__fish_seen_subcommand_from run' -s w -l workflow -d 'Workflow file' -r
complete -c routilux -n '__fish_seen_subcommand_from run' -s p -l param -d 'Parameters (KEY=VALUE)'
complete -c routilux -n '__fish_seen_subcommand_from run' -s o -l output -d 'Output file' -r
complete -c routilux -n '__fish_seen_subcommand_from run' -l timeout -d 'Timeout (seconds)' -r
complete -c routilux -n '__fish_seen_subcommand_from run' -l routines-dir -d 'Routines directory' -r
complete -c routilux -n '__fish_seen_subcommand_from run' -l help -d 'Show help'

# list options
complete -c routilux -n '__fish_seen_subcommand_from list' -a 'routines flows' -d 'Resource type'
complete -c routilux -n '__fish_seen_subcommand_from list' -s c -l category -d 'Filter by category'
complete -c routilux -n '__fish_seen_subcommand_from list' -l routines-dir -d 'Routines directory' -r
complete -c routilux -n '__fish_seen_subcommand_from list' -l dir -d 'Flows directory' -r
complete -c routilux -n '__fish_seen_subcommand_from list' -l format -d 'Output format' -a 'table json plain'
complete -c routilux -n '__fish_seen_subcommand_from list' -l help -d 'Show help'

# validate options
complete -c routilux -n '__fish_seen_subcommand_from validate' -s w -l workflow -d 'Workflow file' -r
complete -c routilux -n '__fish_seen_subcommand_from validate' -l routines-dir -d 'Routines directory' -r
complete -c routilux -n '__fish_seen_subcommand_from validate' -l help -d 'Show help'

# server commands
complete -c routilux -n '__fish_seen_subcommand_from server' -a start -d 'Start the server'
complete -c routilux -n '__fish_seen_subcommand_from server' -a stop -d 'Stop the server'
complete -c routilux -n '__fish_seen_subcommand_from server' -a status -d 'Check server status'

# server start options
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l host -d 'Host to bind'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l port -d 'Port to bind'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l routines-dir -d 'Routines directory' -r
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l reload -d 'Enable auto-reload'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l log-level -d 'Log level' -a 'debug info warning error critical'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from start' -l help -d 'Show help'

# server stop options
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from stop' -l port -d 'Port to stop'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from stop' -s f -l force -d 'Force kill'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from stop' -l help -d 'Show help'

# server status options
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from status' -l port -d 'Port to check'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from status' -l json -d 'Output as JSON'
complete -c routilux -n '__fish_seen_subcommand_from server; and __fish_seen_subcommand_from status' -l help -d 'Show help'

# completion options
complete -c routilux -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish' -d 'Shell type'
complete -c routilux -n '__fish_seen_subcommand_from completion' -l install -d 'Install completion'
complete -c routilux -n '__fish_seen_subcommand_from completion' -l help -d 'Show help'
"""


def _install_completion(shell: str, script: str, quiet: bool):
    """Install completion script to appropriate location.

    Args:
        shell: Shell type (bash, zsh, fish)
        script: Completion script content
        quiet: Whether to suppress output
    """
    if shell == "bash":
        paths = [
            os.path.expanduser("~/.bash_completion.d/routilux"),
            "/etc/bash_completion.d/routilux",
        ]
    elif shell == "zsh":
        paths = [
            os.path.expanduser("~/.zsh/completion/_routilux"),
            "/usr/local/share/zsh/site-functions/_routilux",
        ]
    elif shell == "fish":
        paths = [
            os.path.expanduser("~/.config/fish/completions/routilux.fish"),
        ]
    else:
        click.echo(f"Unknown shell: {shell}", err=True)
        raise click.Abort(1)

    for path in paths:
        try:
            os.makedirs(os.path.dirname(path), exist_ok=True)
            with open(path, "w") as f:
                f.write(script)
            click.echo(f"Installed to: {path}")

            # Provide activation instructions
            if not quiet:
                if shell == "bash":
                    click.echo("\nTo activate, run:")
                    click.echo(f"  source {path}")
                    click.echo("\nOr add to your ~/.bashrc:")
                    click.echo(f"  [ -f {path} ] && source {path}")
                elif shell == "zsh":
                    click.echo("\nTo activate, restart your shell or run:")
                    click.echo("  autoload -U compinit && compinit")
                elif shell == "fish":
                    click.echo("\nCompletion will be available in new fish sessions.")
            return
        except PermissionError:
            continue
        except OSError as e:
            click.echo(f"Error installing to {path}: {e}", err=True)

    click.echo(
        "Could not install completion automatically. Please save the script manually.", err=True
    )
    click.echo("\nScript:")
    click.echo(script)
